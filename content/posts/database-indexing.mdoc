---
title: Database Indexing Overview
status: published
excerpt: >-
  Databases store data in pages (commonly 8 KB each) containing multiple rows.
  Without indexes, finding a specific record can require scanning many pages
  sequentially, which is inefficient and slow. Indexes act as maps, guiding the
  query engine directly to the required data, dramatically reducing lookup
  times.
categories: []
publishedDate: 2025-02-15
tags:
  - database
  - indexing
  - performance
  - backend
  - sql
coverImage: /content/posts/database-indexing/coverImage.webp
seo:
  twitterCard: summary_large_image
editorialComments: []
---
Databases store data in pages (commonly 8 KB each) containing multiple rows. Without indexes, finding a specific record can require scanning many pages sequentially, which is inefficient and slow. Indexes act as maps, guiding the query engine directly to the required data, dramatically reducing lookup times.

## The Indexing Problem & Its Solution

### The Problem Without Indexing

When a database query is executed without an index, the system loads pages sequentially into memory, scanning each for the target data. For large tables, this can mean reading hundreds of thousands or even millions of pages, resulting in high latency.

**Without Index - Full Table Scan:**

```mermaid
flowchart LR
    subgraph Query["Query: SELECT * FROM users WHERE email = 'john@example.com'"]
        direction TB
    end
    
    subgraph Pages["Sequential Page Scan"]
        direction LR
        P1["Page 1<br/>Users 1-5"] --> P2["Page 2<br/>Users 6-10"] --> P3["Page 3<br/>Users 11-15"] --> P4["..."] --> PN["Page N<br/>Users 5M+"]
    end
    
    Query --> Pages
    Pages --> Slow["‚ö†Ô∏è Check EVERY row<br/>O(n) complexity - SLOW!"]
    
    style Query fill:#1e1e2e,stroke:#89b4fa,color:#cdd6f4
    style Pages fill:#1e1e2e,stroke:#45475a,color:#cdd6f4
    style Slow fill:#1e1e2e,stroke:#f38ba8,color:#f38ba8
```

### How Indexes Solve the Problem

Indexes are specialized data structures stored on disk. They provide a pointer (or a set of pointers) to the disk pages where the actual data resides. This means the system can quickly locate and load only the relevant page(s), bypassing a full table scan.

**With Index - Direct Lookup:**

```mermaid
flowchart TB
    Query["Query: SELECT * FROM users WHERE email = 'john@example.com'"]
    
    subgraph Index["B-Tree Index Lookup"]
        direction TB
        IDX["john@example.com ‚Üí Page 3"]
    end
    
    subgraph Target["Target Data Page"]
        direction TB
        P3["Page 3"]
        Users["User 11 ‚úì<br/>User 12<br/>User 13<br/>User 14<br/>User 15"]
        P3 --> Users
    end
    
    Query --> Index
    Index --> Target
    Target --> Fast["‚ö° O(log n) complexity - Much faster!"]
    
    style Query fill:#1e1e2e,stroke:#89b4fa,color:#cdd6f4
    style Index fill:#1e1e2e,stroke:#a6e3a1,color:#a6e3a1
    style Target fill:#1e1e2e,stroke:#f9e2af,color:#cdd6f4
    style Fast fill:#1e1e2e,stroke:#a6e3a1,color:#a6e3a1
```

## Index Types and Visualizations

### B-Tree Index

B-Tree indexes are the most common type. They maintain sorted order and support both exact match and range queries efficiently.

**How It Works:**

1. **Load the Root Node:** The system reads the root of the B-Tree
1. **Traverse Internal Nodes:** Navigate down based on key comparisons
1. **Reach the Leaf Node:** Contains pointers to data pages

**B-Tree Structure:**

```mermaid
flowchart TB
    subgraph Root["Root Node"]
        R["[50, 100]"]
    end
    
    subgraph Level1["Internal Nodes"]
        direction LR
        I1["[25, 40]"]
        I2["[75, 90]"]
        I3["[120, 150]"]
    end
    
    subgraph Leaves["Leaf Nodes (Data Pointers)"]
        direction LR
        L1["1-25"]
        L2["26-40"]
        L3["41-50"]
        L4["51-75"]
        L5["76-90"]
        L6["91-100"]
        L7["101-120"]
        L8["121+"]
    end
    
    subgraph Data["Data Pages"]
        direction LR
        D1["Data"]
        D2["Data"]
        D3["Data"]
        D4["Data"]
        D5["Data"]
        D6["Data"]
        D7["Data"]
        D8["Data"]
    end
    
    R --> I1
    R --> I2
    R --> I3
    
    I1 --> L1
    I1 --> L2
    I1 --> L3
    I2 --> L4
    I2 --> L5
    I2 --> L6
    I3 --> L7
    I3 --> L8
    
    L1 --> D1
    L2 --> D2
    L3 --> D3
    L4 --> D4
    L5 --> D5
    L6 --> D6
    L7 --> D7
    L8 --> D8
    
    Note["Height = log(n)<br/>Only 3-4 levels for millions of rows!"]
    
    style Root fill:#1e1e2e,stroke:#89b4fa,color:#cdd6f4
    style Level1 fill:#1e1e2e,stroke:#fab387,color:#cdd6f4
    style Leaves fill:#1e1e2e,stroke:#a6e3a1,color:#cdd6f4
    style Data fill:#1e1e2e,stroke:#f9e2af,color:#cdd6f4
    style Note fill:#1e1e2e,stroke:#89b4fa,color:#89b4fa
```

### Hash Index

Hash indexes use a hash function to convert a key into a hash value, which then maps directly to a data page. They provide O(1) lookups for exact matches but do not support range queries well.

**Hash Index Flow:**

```mermaid
flowchart LR
    Input["Input Key<br/>john@example.com"] --> Hash["Hash Function<br/>SHA-256"]
    Hash --> Bucket["Hash Map<br/>Bucket 42"]
    Bucket --> Pointer["Data Page Pointer"]
    
    subgraph HashTable["Hash Table (In Memory)"]
        direction TB
        HT1["0x42A... ‚Üí Page 5, Row 23"]
        HT2["0x7F1... ‚Üí Page 12, Row 7"]
        HT3["0xD92... ‚Üí Page 3, Row 41"]
        HT4["..."]
    end
    
    Bucket -.-> HashTable
    
    Note1["‚ö° O(1) Lookup Time"]
    Note2["‚ùå No range queries<br/>(WHERE age > 25)"]
    
    style Input fill:#1e1e2e,stroke:#89b4fa,color:#cdd6f4
    style Hash fill:#1e1e2e,stroke:#fab387,color:#cdd6f4
    style Bucket fill:#1e1e2e,stroke:#a6e3a1,color:#cdd6f4
    style Pointer fill:#1e1e2e,stroke:#f9e2af,color:#cdd6f4
    style HashTable fill:#1e1e2e,stroke:#45475a,color:#cdd6f4
    style Note1 fill:#1e1e2e,stroke:#a6e3a1,color:#a6e3a1
    style Note2 fill:#1e1e2e,stroke:#f38ba8,color:#f38ba8
```

**Note:** Hash indexes are commonly used in in-memory data stores rather than on-disk databases.

### Geospatial Indexes

Geospatial indexes are optimized for two-dimensional data (e.g., latitude and longitude). The three popular types include:

- **Geohashing:** Converts 2D coordinates into 1D strings while preserving spatial locality
- **Quad Trees:** Recursively partitions the space into quadrants, splitting cells only where data density is high
- **R-Trees / Archeries:** A dynamic variant that supports overlapping regions, optimizing spatial queries

**Geospatial Indexing - Quad Tree Structure:**

```mermaid
flowchart TB
    subgraph Root["World Map (Root)"]
        R["Root"]
    end
    
    subgraph Level1["Level 1 - Quadrants"]
        direction LR
        NW["NW Quad<br/>(High Res)"]
        NE["NE Quad<br/>(High Res)"]
        C["Center<br/>(Low Res)"]
    end
    
    subgraph Level2["Level 2 - Sub-quadrants"]
        direction LR
        NW1["NW Detail"]
        NE1["NE Detail"]
        NW2["NW Detail"]
        NE2["NE Detail"]
    end
    
    R --> NW
    R --> NE
    R --> C
    
    NW --> NW1
    NW --> NE1
    NE --> NW2
    NE --> NE2
    
    subgraph Example["Example: Finding Restaurants Near You"]
        direction TB
        E1["üçï Pizza - NW"]
        E2["üçî Burger - NE"]
        E3["üë§ You - Center"]
        E4["üçú Noodles - SW"]
        E5["üåÆ Tacos - SE"]
        E6["üç± Bento - SE"]
    end
    
    Note["Search radius ‚Üí Only check relevant quadrants! ‚ö°"]
    
    style Root fill:#1e1e2e,stroke:#89b4fa,color:#cdd6f4
    style Level1 fill:#1e1e2e,stroke:#fab387,color:#cdd6f4
    style Level2 fill:#1e1e2e,stroke:#a6e3a1,color:#cdd6f4
    style Example fill:#1e1e2e,stroke:#f9e2af,color:#cdd6f4
    style Note fill:#1e1e2e,stroke:#89b4fa,color:#89b4fa
```

### Inverted Index

Inverted indexes are designed for full-text search. They map each term (or token) to the documents or data pages in which they appear.

**Inverted Index Structure:**

```mermaid
flowchart TB
    subgraph Docs["Documents to Index"]
        direction LR
        Doc1["Document 1<br/>'B-Trees are fast...'"]
        Doc2["Document 2<br/>'Hash tables are limited...'"]
    end
    
    subgraph Process["Tokenization & Processing"]
        Token["Text Processing<br/>& Stemming"]
    end
    
    subgraph Inverted["Inverted Index"]
        direction TB
        T1["b-tree ‚Üí Doc1, Doc3, Doc7"]
        T2["fast ‚Üí Doc1, Doc4, Doc8"]
        T3["data ‚Üí Doc1, Doc2, Doc5, Doc9"]
        T4["hash ‚Üí Doc2, Doc6, Doc10"]
        T5["table ‚Üí Doc2, Doc5, Doc8"]
        T6["cache ‚Üí Doc2, Doc4, Doc11"]
    end
    
    subgraph Query1["Query: 'fast hash'"]
        Q1["fast: Doc1, Doc4, Doc8<br/>hash: Doc2, Doc6, Doc10<br/>‚ö†Ô∏è No intersection"]
    end
    
    subgraph Query2["Query: 'fast b-tree'"]
        Q2["fast: Doc1, Doc4, Doc8<br/>b-tree: Doc1, Doc3, Doc7<br/>‚úì Result: Doc1"]
    end
    
    Docs --> Process
    Process --> Inverted
    Inverted -.-> Query1
    Inverted -.-> Query2
    
    style Docs fill:#1e1e2e,stroke:#89b4fa,color:#cdd6f4
    style Process fill:#1e1e2e,stroke:#fab387,color:#cdd6f4
    style Inverted fill:#1e1e2e,stroke:#a6e3a1,color:#cdd6f4
    style Query1 fill:#1e1e2e,stroke:#f38ba8,color:#f38ba8
    style Query2 fill:#1e1e2e,stroke:#a6e3a1,color:#a6e3a1
```

## Indexing Decision Flowchart

The following flowchart helps determine the appropriate indexing strategy based on the query characteristics and data type.

```mermaid
flowchart TD
    Start["Need efficient<br/>data access?"] -->|No| FTS1["Full Table Scan<br/>(OK for small tables)"]
    Start -->|Yes| Large["Large number<br/>of rows?"]
    
    Large -->|No| FTS2["Full Table Scan"]
    Large -->|Yes| Type["What type<br/>of data?"]
    
    Type -->|Text| Inverted["Inverted Index<br/>Elasticsearch,<br/>PostgreSQL FTS"]
    Type -->|Location| Geo["Geospatial Index<br/>PostGIS, etc."]
    Type -->|Numeric/Other| QueryType
    
    subgraph QueryType["Query Type"]
        direction TB
        Exact["Exact Match<br/>Only?"] -->|Yes| Hash["Hash Index<br/>or B-Tree"]
        Exact -->|No| Range["Range Queries<br/>Needed?"]
        Range -->|Yes| BTree1["B-Tree Index<br/>Default choice"]
        Range -->|No| BTree2["B-Tree Index<br/>Default choice"]
    end
    
    style Start fill:#1e1e2e,stroke:#89b4fa,color:#cdd6f4
    style FTS1 fill:#1e1e2e,stroke:#6c7086,color:#6c7086
    style FTS2 fill:#1e1e2e,stroke:#6c7086,color:#6c7086
    style Large fill:#1e1e2e,stroke:#fab387,color:#cdd6f4
    style Type fill:#1e1e2e,stroke:#fab387,color:#cdd6f4
    style Inverted fill:#1e1e2e,stroke:#a6e3a1,color:#a6e3a1
    style Geo fill:#1e1e2e,stroke:#a6e3a1,color:#a6e3a1
    style Hash fill:#1e1e2e,stroke:#f9e2af,color:#f9e2af
    style BTree1 fill:#1e1e2e,stroke:#89b4fa,color:#89b4fa
    style BTree2 fill:#1e1e2e,stroke:#89b4fa,color:#89b4fa
```

**Quick Reference Table:**

{% table %}
- Scenario
- Recommended Index
- Why
---
- Primary key lookups
- B-Tree
- Balanced performance, supports range queries
---
- Full-text search
- Inverted Index
- Optimized for text token matching
---
- Location-based queries
- Geospatial
- Efficient 2D coordinate lookups
---
- Exact match cache lookups
- Hash Index
- O(1) constant time access
---
- Range queries (BETWEEN, >, <)
- B-Tree
- Sorted structure enables ranges
---
- Join operations
- B-Tree on FK columns
- Fast lookups during joins
{% /table %}

## Additional Considerations

### Performance

Indexes reduce disk I/O, leading to faster query responses.

**Performance Comparison:**

{% table %}
- Table Size
- Without Index
- With B-Tree Index
- Speedup
---
- 1,000 rows
- 10 ms
- 2 ms
- 5x
---
- 100,000 rows
- 500 ms
- 3 ms
- 167x
---
- 10,000,000 rows
- 50,000 ms
- 4 ms
- 12,500x
{% /table %}

### Trade-Offs

While indexes speed up data retrieval, they add overhead to write operations (inserts, updates, and deletes).

**Write Operation Impact:**

{% table %}
- Operation
- Without Index
- With 3 Indexes
- Overhead
---
- INSERT
- 1 unit
- 3.5 units
- 3.5x slower
---
- UPDATE (indexed columns)
- 1 unit
- 4 units
- 4x slower
---
- UPDATE (non-indexed)
- 1 unit
- 1.2 units
- 1.2x slower
---
- DELETE
- 1 unit
- 3.2 units
- 3.2x slower
{% /table %}

**Best Practice:** Only index columns frequently used in WHERE, JOIN, and ORDER BY clauses.

### Real-World Usage

{% table %}
- Index Type
- Common Use Cases
- Example Technologies
---
- B-Trees
- Relational databases for general-purpose indexing
- PostgreSQL, MySQL, SQL Server
---
- Geospatial Indexes
- Mapping or location-based searches
- PostGIS, MongoDB 2dsphere
---
- Inverted Indexes
- Full-text search engines
- Elasticsearch, PostgreSQL FTS
---
- Hash Indexes
- In-memory stores or specific exact-match use cases
- Redis, Memcached
---
- Bitmap Indexes
- Data warehousing with low cardinality columns
- Oracle, PostgreSQL
---
- GiST/GIN
- Complex data types (arrays, JSON, ranges)
- PostgreSQL
{% /table %}

## Conclusion

Effective database indexing is essential for optimizing query performance and building scalable systems. By understanding the strengths and limitations of each index type, you can make informed decisions on which strategy to implement for a given application scenario.

**Key Takeaways:**

1. **Start with B-Tree indexes** - They handle 95% of use cases effectively
1. **Index only what you query** - Every index adds write overhead
1. **Monitor query performance** - Use EXPLAIN to verify index usage
1. **Choose specialized indexes for specialized data** - Geospatial for locations, inverted for text
1. **Keep indexes maintained** - Rebuild periodically to prevent bloat

Remember: The best index is the one that gets used by your query planner!
